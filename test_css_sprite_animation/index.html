<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <!--
            I'm investigating this method because I'm seeing flicker; I'm hoping
            this decreases the image load time and eliminates the flicker.  Also
            I told Jeff I'd stick to just one sprite and I'm not ready to further
            generalize a sprite library so I thought it would be informative to 
            find a new/different way to do this.

        Notes:

            It looks like the evaluation of variables with CSS animations can 
            cause unexpected slowdowns.  It may be better to hard code the values
            directly into the classes.

            On the plus side - like I thought, this gets ride of the flicker entirely and 
            makes the animation much smoother.

            The only solution I could find for scaling involved using JavaScript to
            calculate the scale factor and then applying it to the transform property.
            I don't see a way to do this in CSS.

            Setting the transform-origin to top left is important to keep the world
            from moving around as it scales.



        -->

        <!-- References 
        Making CSS animations using a sprite sheet
        https://blog.logrocket.com/making-css-animations-using-a-sprite-sheet/
        Ideas:
            Uses the a method of moving a viewport over the image;
            Uses CSS keyframes to move the viewport;
        Questions:
            How do I learn more about Figma?
            How do I scale the background image?
            Seems to be missing code.
            Couldn't get to work - may be my limited understanding of CSS animations generally.

        How to Create a CSS Sprite Animation With steps()
        https://blog.teamtreehouse.com/css-sprite-sheet-animations-steps
        Ideas:
            Expands on the above by showing how to use the CSS animation property;
            Play scrolls the whole image; steps scrolls a portion of the image;      
            [Steps should match the number of frames in the sprite sheet]
            The infinite keyword keeps things going forever.       
        Questions:

    -->
        <!--div class="monster"></div>
        <div class="terminal"></div-->
        <div id="container">
            <div class="world" id="world"></div>
        </div>

        <style>
            :root {
                --world-sprite-width: 82px;
                --world-sprite-height: 82px;
                --world-spritesheet-width: 3936px;
                --world-spritesheet-height: 82px;
                --world-spritesheet-src: url("world_sprite_sheet2.gif");
                --world-spritesheet-frames: 48;
                --world-element: world;
                --world-container: container;
            }

            body {
                background-color: #24aecd;
            }

            #container {
                width: 20vh;
                height: 20vh;
            }

            .world {
                width: var(--world-sprite-height);
                height: var(--world-sprite-width);
                background: var(--world-spritesheet-src) left center;
                animation: spin_world 1s steps(var(--world-spritesheet-frames)) infinite;    
                transform-origin: top left;             
            }

            @keyframes spin_world {
                100% {
                    background-position: var(--world-spritesheet-width);
                 }
            }

        </style>

        <script>
            function worldResponsiveResize()
            {
                // I don't see a way to solve this in CSS
                // So I'm copying what I did for the scientist
                console.log("Resize World sprite now.")
                
                const WORLD_ELEMENT_NAME = getComputedStyle(document.documentElement).getPropertyValue("--world-element");
                const CONTAINER_ELEMENT_NAME = getComputedStyle(document.documentElement).getPropertyValue("--world-container");

                const ROOT = document.documentElement;

                const WORLD = document.getElementById(WORLD_ELEMENT_NAME);
                const CONTAINER = document.getElementById(CONTAINER_ELEMENT_NAME);
                
                let transform = `scale(1)`;          
                
                const worldHeight = getComputedStyle(WORLD).height;
                const containerHeight = getComputedStyle(CONTAINER).height;
                const scale = parseFloat(containerHeight) / parseFloat(worldHeight);
                
                transform = `scale(${scale})`;
                WORLD.style.transform=transform;

            }

            // Set the initial size of the world sprite
            // This is a hack to get the world sprite to scale
            // to the size of the container.
            worldResponsiveResize();

            // Add a listener to resize the world sprite
            // when the window is resized
            addEventListener("resize", worldResponsiveResize);
        </script>
    </body>
</html>
